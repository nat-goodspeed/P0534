\newpage
\abschnitt{Additional notes}

\uabschnitt{GPU}

\cc as proposed in this paper is solely a CPU operation. It cannot be used to
create a GPU execution agent, or to create or resume a CPU context from code
running on a GPU.


\uabschnitt{SIMD}

does not interfere with \cc and can be used as usual.\\

Of course, depending on the calling convention, some micro-processor registers
dedicated to SIMD might be preserved and restored too
\footnote{\emph{MS Windows x64} calling convention}.


\uabschnitt{TLS}

\cc is TLS-agnostic - best practice related to TLS applies to \cc too. (But
see P0772R0.)\\

\cc only preserves and restores micro-processor registers at its invocation.


\uabschnitt{Migration between threads}

is forbidden. A \cont may only be resumed on the \cpp{std::thread} on which it
was launched.

\uabschnitt{Relationship to executors}

The \cc facility is intended to compose with executors. The authors envision
an executor implementation that runs each passed work item on a \cc context.
But neither \cc nor the executors proposal \emph{depend} on each other.
