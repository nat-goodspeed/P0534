\abschnitt{Design}\label{design}

Because \cont \bfs{contains} only its
\bfs{stack pointer} as a member variable, it is proposed as a
\bfs{pure data structure}.


\uabschnitt{Passing data}\label{subsec:data}

Data are passed to another context as additional arguments of \call and
\op.\\
With functions \davail and \dget the code can test for data and if desired
retrieve the data.
\cppf{passing_single}
The \cpp{callcc()} call at (0) enters the lambda and passes 1 into the
new context. The value is retrieved as \cpp{j}, as shown by (1). The expression
\cpp{caller(j+1)} at (2) resumes the original context (represented
within the lambda by \cpp{caller}) and transfers back an integer of \cpp{j+1}.
The assignment at (3) sets \cpp{i} to \cpp{j+1}.\\
The call to \cpp{lambda()} at (4) (note that no data is passed) resumes the
lambda, returning from the \cpp{caller(j+1)} call at (2). Here, too,
we replace the \cont instance \cpp{caller} invalidated by the \op call at (2)
with the new instance returned by that same \op call.\\
Finally the lambda returns (the updated) \cpp{caller} at (5), terminating its
context.\\
Since the updated \cpp{caller} represents the continuation suspended by the call at
(4), control returns to \main.\\
However, since context \cpp{lambda} has now terminated, the updated \cpp{lambda} is
invalid. Its \opbool returns \cpp{false}; its \cpp{operator\!()} returns
\cpp{true}.\\
It may seem tricky to keep track of which \cont instance is currently valid,
representing the state of the suspended context. Please bear in mind that this
facility is intended as a high-performance foundation for higher-level
libraries. It is not intended to be directly consumed by applications.\\
Multiple arguments can be transferred into another continuation too.
\cppf{passing_multiple}
\cpp{std::get\_data<int,int>(caller)} returns a \cpp{std::tuple<int,int>}
containing the values passed by the \call call at (0).


\uabschnitt{main() and thread functions}\label{subsec:main}

\main as well as the \entryfn of a thread can be represented by a continuation.
That \cont instance is synthesized when the running context suspends, and is
passed into the newly-resumed context.
\cppf{simple}
The \cpp{callcc()} call at (0) enters the lambda. The \cont\ \cpp{caller} at (1)
represents the execution context of \main. Returning \cpp{caller} at (2) resumes the
original context, switching back to \main.


\uabschnitt{\cc and std::thread}
Any continuation represented by a valid \cont instance is necessarily suspended.\\
It is valid to resume a \cont instance on any thread -- \emph{except} that
since the operating system is responsible for the stack allocated for \main,
as well as each \cpp{std::thread}, you must not attempt to resume a \cont
instance representing any such context on any thread other
than its own. \cpp{any\_thread()} tests for this.\\
If, for \cont\ \cpp{c}, \cpp{std::any\_thread(c)} returns \cpp{false}, it is
only valid to resume \cpp{c} on the thread on which it was initially
launched.


\uabschnitt{Termination}
When the \entryfn invoked by \cc returns a valid \cont instance,
the running context is terminated. Control switches to the continuation
indicated by the returned \cont instance.\\
Returning an invalid \cont instance (\opbool returns \cpp{false}) invokes
undefined behavior.\\
If the \entryfn returns the same \cont instance it was originally
passed (or rather, the most recently updated instance returned from \call or the
previous instance's \op), control returns to the context that most
recently resumed the running callable. However, the callable may return (switch
to) any reachable valid \cont instance.


\uabschnitt{Exceptions}\label{subsec:exceptions}
If an uncaught exception escapes from the \entryfn, \cpp{std::terminate} is
called.


\uabschnitt{Invoke function on top of a continuation}
Sometimes it is useful to invoke a new function (for instance, to throw an
exception) on top of a continuation. For this purpose you may pass to\\
\cpp{operator()(invoke\_ontop\_arg\_t,Fn &&,Args ...)}:

\begin{itemize}
  \item the special argument \cpp{invoke\_ontop\_arg}
  \item the function to execute
  \item any additional arguments.
\end{itemize}

Like an \entryfn passed to \call, the function passed in this case must
accept an rvalue reference to \cont. However, instead of necessarily returning
a \cont, it may return a single type or a \cpp{std::tuple}. Whatever value(s)
it returns will become available to the context referenced by \cpp{*this} as
the data tested by \davail and retrieved by \dget.\\

Suppose that code running on the program's main context calls \cpp{callcc(f)},
thereby entering \cpp{f()}. This is the point at which \cpp{mc} is synthesized
and passed into \cpp{f()}.\\
Suppose further that after doing some work, \cpp{f()} calls \cpp{mc()},
thereby switching context back to the main context. \cpp{f()} remains suspended
in the call to \cpp{mc()}.\\
At this point the main context calls \cpp{f\_ct(invoke\_ontop\_arg, g);}
where \cpp{g()} is declared as\\
\cpp{int g(continuation &&);} \cpp{g()} is entered in the context of \cpp{f()}.
It is as if \cpp{f()}'s call to \cpp{mc()} directly called \cpp{g()}.\\
Function \cpp{g()} has the same range of possibilities as any function called on
\cpp{f()}'s context. Its special invocation only matters when control leaves it
in either of two ways:

\begin{enumerate}
  \item If \cpp{g()} throws an exception, that exception unwinds all previous
        stack entries in that context (such as \cpp{f()}'s) as well, back to a
        matching \cpp{catch} clause.\footnote{As stated in \nameref{subsec:exceptions},
        if there is no matching \cpp{catch} clause in that context,
        \cpp{std::terminate()} is called.}\footnote{There are only two ways to
        terminate a given context without terminating the whole process. One
        is to switch to some context that will destroy the continuation passed
        (or returned) to it. The other is to return a valid continuation from
        the \entryfn. If an \cpp{invoke\_ontop\_arg} function throws an
        exception, it is good practice to bind into the exception object
        the continuation passed into the \cpp{invoke\_ontop\_arg} function so that
        a \cpp{catch} clause in the \entryfn can return that continuation.}
  \item If \cpp{g()} returns, its return value provides data for
        \cpp{f()}'s suspended \cpp{mc()} call.
\end{enumerate}

\cppf{ontop}

Control passes from (0) to (1) to (2), and so on.\\
The \cpp{f\_ct(invoke\_ontop\_arg, g, data+1)} call at (8) passes control
to \cpp{g()} on the context of \cpp{f()}.\\
The \cpp{return} statement at (9) causes the \op call at (6) to return,
executing the assignment at (10). The \cpp{int} returned by \cpp{g()} is
accessed at (11).\\
Finally, \cpp{f()} returns its own \cpp{mc} variable, switching back to the main
context.


\uabschnitt{Stack destruction}\label{subsec:destruction}
On construction of a continuation with \call a stack is allocated. If the
\entryfn returns, the stack will be destroyed. If the function has not
yet returned and the \nameref{subpara:destructor} of a valid \cont instance (\opbool
returns \cpp{true}) is called, the stack will be unwound and destroyed.
\footnote{An implementation is free to unwind the stack without throwing an
exception.}\\
The stack on which \cpp{main()} is executed, as well as the stack implicitly
created by \cpp{std::thread}'s constructor, is allocated by the operating
system. Such stacks are recognized by \cont, and are not deallocated by its
destructor.


\uabschnitt{Stack allocators}\label{subsec:stackalloc}
are used to create stacks.\footnote{This concept, along with \call accepting
\cpp{std::allocator\_arg\_t}, is an optional part of the proposal. It might be
that implementations can reliably infer the optimal stack representation.}
Stack allocators might implement arbitrary stack strategies. For instance, a
stack allocator might append a guard page at the end of the stack, or cache
stacks for reuse, or create stacks that grow on demand.\\
Because stack allocators are provided by the implementation, and are only used
as parameters of \call, the StackAllocator concept is an implementation detail,
used only by the internal mechanisms of the \cc implementation. Different
implementations might use different StackAllocator concepts.\\
However, when an implementation provides a stack allocator matching one of
the descriptions below, it should use the specified name.\\
Possible types of stack allocators:
\begin{itemize}
    \item \cpp{protected\_fixedsize}: The constructor accepts a \cpp{size\_t}
        parameter. This stack allocator constructs a contiguous stack of
        specified size, appending a guard page at the end to protect against
        overflow. If the guard page is accessed (read or write operation), a
        segmentation fault/access violation is generated by the operating
        system.
    \item \cpp{fixedsize}: The constructor accepts a \cpp{size\_t} parameter.
        This stack allocator constructs a contiguous stack of specified size.
        In contrast to \cpp{protected\_fixedsize}, it does not append a guard
        page. The memory is simply managed by \cpp{std::malloc()}
        and \cpp{std::free()}, avoiding kernel involvement.
    \item \cpp{segmented}: The constructor accepts a \cpp{size\_t} parameter.
        This stack allocator creates a segmented stack with the specified
        initial size, which grows on demand.
\end{itemize}

\uabschnitt{std::continuation}
declaration of class \cont
\cppf{cont}
\paragraph*{member functions}
\subparagraph*{(constructor)}
constructs new continuation\\

\begin{tabular}{ l l }
    \midrule

    \cpp{continuation() noexcept} & (1)\\

    \midrule

    \cpp{continuation(continuation&& other)} & (2)\\

    \midrule

    \cpp{continuation(const continuation& other)=delete} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] This constructor instantiates an invalid \cont. Its \opbool
              returns \cpp{false}; its \cpp{operator\!()} returns \cpp{true}.
    \item[2)] moves underlying state to new \cont
    \item[3)] copy constructor deleted
\end{description}

\subparagraph*{(destructor)}\label{subpara:destructor}
destroys a continuation\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~continuation()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \cont instance. If this instance represents a context
              of execution (\opbool returns \cpp{true}), then the context of
              execution is destroyed too. Specifically, the stack is unwound. As
              noted in \nameref{subsec:destruction}, an implementation is free to
              unwind the stack either by throwing an exception or by
              intrinsics not requiring \cpp{throw}.\footnote{If the
              implementation unwinds the stack by throwing an exception, it
              should throw an exception with a conventional name,
              e.g. \cpp{std::unwind}. In a program in which exceptions are
              thrown, it is prudent to code a context's \entryfn with a
              last-ditch \cpp{catch (...)} clause: in general, exceptions must
              \emph{not} leak out of the \entryfn. However, if the
              implementation's stack unwinding is implemented by throwing an
              exception, a correct \entryfn\ \cpp{try} statement
              must \cpp{catch (std::unwind const&)} and rethrow it.}
\end{description}

\subparagraph*{operator=}
moves the continuation object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{continuation& operator=(continuation&& other)} & (1)\\

    \midrule

    \cpp{continuation& operator=(const continuation& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}


\subparagraph*{operator()}
resumes a continuation\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template< typename ...Args >}\\
    \cpp{continuation operator()( Args ... args)} & (1)\\

    \midrule

    \cpp{template< typename Fn, typename ...Args >}\\
    \cpp{continuation operator()( invoke\_ontop\_arg\_t, Fn && fn, Args ... args)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] suspends the active context, resumes continuation \cpp{*this}
    \item[2)] suspends the active context, resumes continuation \cpp{*this} but
              invokes \cpp{fn(args ...)} in the resumed context (on top of the
              last stack frame)
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[...args] passed to the resumed continuation - see section
                   \nameref{subsec:data}
    \item[fn] function invoked ontop of resumed continuation\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[continuation] the returned instance represents the execution context
                        (continuation) that has been suspended in order to
                        resume the current context
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate} if an exception escapes \entryfn\ 
              \cpp{fn}\\
\end{description}

{\bfseries Preconditions}
\begin{description}
    \item[1)] \cpp{*this} represents a context of execution (\opbool returns
               \cpp{true})
    \item[2)] \cpp{any\_thread(*this)} returns \cpp{true}, or the running thread is
              the same thread on which \cpp{*this} ran previously.
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{*this} is invalidated (\opbool returns \cpp{false})
\end{description}

{\bfseries Notes}
\newline
\op preserves the execution context of the calling context as well as stack
parts like \emph{parameter list} and \emph{return address}.\footnote{required
only by some x86 ABIs} Those data are restored if the calling context is
resumed.
\newline
A suspended \cpp{continuation} can be destroyed. Its resources will be cleaned
up at that time.
\newline
The returned \cpp{continuation} indicates whether the suspended context
has terminated (returned from \entryfn) via \opbool. If the returned
\cpp{continuation} has terminated, no data may be retrieved.
\newline
Because \op invalidates the instance on which it is called, \emph{no valid
\cont instance ever represents the currently-running context.}
\newline
When calling \op, it is conventional to replace the newly-invalidated
instance -- the instance on which \op was called -- with the new instance
returned by that \op call. This helps to avoid inadvertent calls to \op
on the old, invalidated instance.

\subparagraph*{operator bool}
test whether continuation is valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{explicit operator bool() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a context of
              execution, \cpp{false} otherwise.
\end{description}

{\bfseries Notes}
\newline
A \cont instance might not represent a context of execution for any of a
number of reasons.
\begin{itemize}
    \item It might have been default-constructed.
    \item It might have been assigned to another instance, or passed into a
          function.\\
          \cont instances are move-only.
    \item It might already have been resumed (\op called) - calling \op
          invalidates the instance.
    \item The \entryfn might have voluntarily terminated the
          context by returning.
\end{itemize}
The essential points:
\begin{itemize}
    \item Regardless of the number of \cont declarations, exactly one\\
          \cont instance represents each suspended context.
    \item No \cont instance represents the currently-running context.
\end{itemize}

\subparagraph*{operator!}
test whether continuation is invalid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator\!() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{false} if \cpp{*this} represents a context of
              execution, \cpp{true} otherwise.
\end{description}

{\bfseries Notes}
\newline
See {\bfseries Notes} for \opbool.

\subparagraph*{(comparisons)}
establish an arbitrary total ordering for \cont instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator==(const continuation& other) const noexcept} & (1)\\

    \midrule

    \cpp{bool operator\!=(const continuation& other) const noexcept} & (1)\\

    \midrule

    \cpp{bool operator<(const continuation& other) const noexcept} & (2)\\

    \midrule

    \cpp{bool operator>(const continuation& other) const noexcept} & (2)\\

    \midrule

    \cpp{bool operator<=(const continuation& other) const noexcept} & (2)\\

    \midrule

    \cpp{bool operator>=(const continuation& other) const noexcept} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Every invalid \cont instance compares equal to every other
              invalid instance. But because the running context is never
              represented by a valid \cont instance, and because every
              suspended context is represented by exactly one valid
              instance, \emph{no valid instance can ever compare equal to any
              other valid instance.}
    \item[2)] These comparisons establish an arbitrary total ordering of \cont
              instances, for example to store in ordered containers. (However,
              key lookup is meaningless, since you cannot construct a search
              key that would compare equal to any entry.) There is no
              significance to the relative order of two instances.
\end{description}

\subparagraph*{swap}
swaps two \cont instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(continuation& other) noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Exchanges the state of \cpp{*this} with \cpp{other}.\\
\end{description}


\uabschnitt{std::callcc()}

create and enter a new context, capturing the current execution context (the
{\bfseries current continuation}) in a \cont and passing it to the
specified \entryfn.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template< typename Fn, typename ...Args >}\\
    \cpp{continuation callcc( Fn && fn, Args ...args)} & (1)\\

    \midrule

    \cpp{template< typename StackAlloc, typename Fn, typename ...Args >}\\
    \cpp{continuation callcc( std::allocator\_arg\_t, StackAlloc salloc, Fn && fn, Args ...args)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and immediately enters the new execution context
              (executing \cpp{fn}). The current execution context is suspended,
              wrapped in a continuation (\cont) and passed as argument to
              \cpp{fn}.
    \item[2)] takes a callable as argument, requirements as for (1). The stack
              is constructed using \emph{salloc}
              (see \nameref{subsec:stackalloc}).\footnote{This constructor, along with
              the \nameref{subsec:stackalloc} section, is an optional part of the
              proposal. It might be that implementations can reliably infer the
              optimal stack representation.}
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[fn]      callable (function, lambda, functor) executed in the new
                   context; expected signature \cpp{continuation(continuation &&)} 
    \item[...args] data transferred to the new context - see section
                   \nameref{subsec:data}\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[continuation] the returned instance represents the execution context
                        (continuation) that was suspended in order to
                        resume the current context
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate} if an exception escapes \entryfn\ 
              \cpp{fn}\\
\end{description}

{\bfseries Notes}
\newline
\call preserves the execution context of the calling context as well as stack
parts like \emph{parameter list} and \emph{return address}.
\footnote{required only by some x86 ABIs} Those data are restored if the calling
context is resumed.\\
A suspended \cpp{continuation} can be destroyed. Its resources will be cleaned
up at that time.\\
On return \cpp{fn} has to specify a \cont to which the execution control is
transferred.\\
If an instance with valid state goes out of scope and its \cpp{fn} has not yet
returned, the stack is unwound and deallocated.


\uabschnitt{std::data\_available()}

test if data are present\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool data\_available( continuation && c)} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \call or \op have been invoked with
              additional data as argument (\cpp{args})
\end{description}


\uabschnitt{std::get\_data()}

transfer of data\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template< typename Arg >}\\
    \cpp{Arg get\_data( continuation && c)} & (1)\\

    \midrule

    \cpp{template< typename ...Args >}\\
    \cpp{std::tuple< Args... > get\_data( continuation && c)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] transfers single datum from continuation \cpp{c} into this context
    \item[2)] transfers multiple data from continuation \cpp{c} into this
              context
\end{description}

{\bfseries Notes}
\newline
The template argument(s) passed to \cpp{get\_data()} must match in number and
type the actual argument types passed to \call or \op.

\uabschnitt{std::any\_thread()}

test whether suspended continuation may be resumed on a different thread\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool any\_thread( continuation const& c) const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{false} if \cpp{c} must be resumed on the same
              thread on which it previously ran, \cpp{true} otherwise
\end{description}

{\bfseries Notes}
\newline
As stated in \nameref{subsec:main}, a \cont instance can represent the initial
context on which the operating system runs \main, or the context created by
the operating system for a new \cpp{std::thread}.

Attempting to resume such a \cont instance on any thread other than its
original thread invokes undefined behavior. \cpp{any\_thread()} allows
consumer code to distinguish this case by returning \cpp{false}.
