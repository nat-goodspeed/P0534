\abschnitt{API}\label{api}

\uabschnitt{std::continuation}
declaration of class \cont
\cppf{continuation}
\paragraph*{member functions}

\subparagraph*{(constructor)}
constructs new continuation\\

\begin{tabular}{ l l }
    \midrule

    \cpp{continuation() noexcept} & (1)\\

    \midrule

    \cpp{continuation(continuation&& other)} & (2)\\

    \midrule

    \cpp{continuation(const continuation& other)=delete} & (3)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] This constructor instantiates an invalid \cont. Its \opbool
              returns \cpp{false}; its \cpp{operator\!()} returns \cpp{true}.
    \item[2)] moves underlying state to new \cont
    \item[3)] copy constructor deleted
\end{description}


\subparagraph*{(destructor)}\label{subpara:destructor}
destroys a continuation\\

\begin{tabular}{ l l }
    \midrule

    \cpp{\~continuation()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] destroys a \cont instance. If this instance represents a context
              of execution (\opbool returns \cpp{true}), then the context of
              execution is destroyed too. Specifically, the stack is unwound.
              An implementation is free to
              unwind the stack either by throwing \cpp{std::unwind} or by
              intrinsics not requiring \cpp{throw}.
              \footnote{ In a program in which exceptions are thrown, it is
              prudent to code a context's \entryfn with a last-ditch
              \cpp{catch (...)} clause: in general, exceptions must
              \emph{not} leak out of the \entryfn. However, if the
              implementation's stack unwinding is implemented by throwing an
              exception, a correct \entryfn\ \cpp{try} statement
              must \cpp{catch (std::unwind const&)} and rethrow it.}
\end{description}


\subparagraph*{operator=}
moves the continuation object\\

\begin{tabular}{ l l }
    \midrule

    \cpp{continuation& operator=(continuation&& other)} & (1)\\

    \midrule

    \cpp{continuation& operator=(const continuation& other)=delete} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] assigns the state of \cpp{other} to \cpp{*this} using move semantics
    \item[2)] copy assignment operator deleted
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[other]   another execution context to assign to this object\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[*this]
\end{description}


\subparagraph*{resume()}
resumes a continuation\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template< typename ...Args >}\\
    \cpp{continuation resume( Args ... args)} & (1)\\

    \midrule

    \cpp{template< typename Fn, typename ...Args >}\\
    \cpp{continuation resume\_with( Fn && fn, Args ... args)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] suspends the active context, resumes continuation \cpp{*this}
    \item[2)] suspends the active context, resumes continuation \cpp{*this} but
              invokes \cpp{fn(args ...)} in the resumed context (on top of the
              last stack frame)
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[...args] passed to the resumed continuation
    \item[fn] function invoked ontop of resumed continuation\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[continuation] the returned instance represents the execution context
                        (continuation) that has been suspended in order to
                        resume the current context
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate} if an exception escapes \entryfn\ 
              \cpp{fn}\\
\end{description}

{\bfseries Preconditions}
\begin{description}
    \item[1)] \cpp{*this} represents a context of execution (\opbool returns
               \cpp{true})
    \item[2)] \cpp{any\_thread()} returns \cpp{true}, or the running thread is
              the same thread on which \cpp{*this} ran previously.
\end{description}

{\bfseries Postcondition}
\begin{description}
    \item[1)] \cpp{*this} is invalidated (\opbool returns \cpp{false})
\end{description}

{\bfseries Notes}
\newline
\resume preserves the execution context of the calling context as well as stack
parts like \emph{parameter list} and \emph{return address}.\footnote{required
only by some x86 ABIs} Those data are restored if the calling context is
resumed.
\newline
A suspended \cpp{continuation} can be destroyed. Its resources will be cleaned
up at that time.
\newline
The returned \cpp{continuation} indicates whether the suspended context
has terminated (returned from \entryfn) via \opbool. If the returned
\cpp{continuation} has terminated, no data may be retrieved.
\newline
Because \resume invalidates the instance on which it is called, \emph{no valid
\cont instance ever represents the currently-running context.}
\newline
When calling \resume, it is conventional to replace the newly-invalidated
instance -- the instance on which \resume was called -- with the new instance
returned by that \resume call. This helps to avoid inadvertent calls to \resume
on the old, invalidated instance.


\subparagraph{data\_available()}
test if data are present\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool data\_available()} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \callcc or \resume have been invoked with
              additional data as argument (\cpp{args})
\end{description}


\subparagraph{get\_data()}
transfer of data\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template< typename Arg >}\\
    \cpp{Arg get\_data()} & (1)\\

    \midrule

    \cpp{template< typename ...Args >}\\
    \cpp{std::tuple< Args... > get\_data()} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] transfers single datum from continuation \cpp{c} into this context
    \item[2)] transfers multiple data from continuation \cpp{c} into this
              context
\end{description}

{\bfseries Notes}
\newline
The template argument(s) passed to \cpp{get\_data()} must match in number and
type the actual argument types passed to \callcc or \resume.


\subparagraph{any\_thread()}
test whether suspended continuation may be resumed on a different thread\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool any\_thread() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{false} if \cpp{c} must be resumed on the same
              thread on which it previously ran, \cpp{true} otherwise
\end{description}

{\bfseries Notes}
\newline
A \cont instance can represent the initial context on which the operating
system runs \main, or the context created by the operating system for a
new \cpp{std::thread}.

Attempting to resume such a \cont instance on any thread other than its
original thread invokes undefined behavior. \cpp{any\_thread()} allows
consumer code to distinguish this case by returning \cpp{false}.


\subparagraph*{operator bool}
test whether continuation is valid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{explicit operator bool() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{true} if \cpp{*this} represents a context of
              execution, \cpp{false} otherwise.
\end{description}

{\bfseries Notes}
\newline
A \cont instance might not represent a context of execution for any of a
number of reasons.
\begin{itemize}
    \item It might have been default-constructed.
    \item It might have been assigned to another instance, or passed into a
          function.\\
          \cont instances are move-only.
    \item It might already have been resumed (\resume called) - calling \resume
          invalidates the instance.
    \item The \entryfn might have voluntarily terminated the
          context by returning.
\end{itemize}
The essential points:
\begin{itemize}
    \item Regardless of the number of \cont declarations, exactly one\\
          \cont instance represents each suspended context.
    \item No \cont instance represents the currently-running context.
\end{itemize}


\subparagraph*{operator!}
test whether continuation is invalid\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator\!() const noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] returns \cpp{false} if \cpp{*this} represents a context of
              execution, \cpp{true} otherwise.
\end{description}

{\bfseries Notes}
\newline
See {\bfseries Notes} for \opbool.

\subparagraph*{(comparisons)}
establish an arbitrary total ordering for \cont instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{bool operator==(const continuation& other) const noexcept} & (1)\\

    \midrule

    \cpp{bool operator\!=(const continuation& other) const noexcept} & (1)\\

    \midrule

    \cpp{bool operator<(const continuation& other) const noexcept} & (2)\\

    \midrule

    \cpp{bool operator>(const continuation& other) const noexcept} & (2)\\

    \midrule

    \cpp{bool operator<=(const continuation& other) const noexcept} & (2)\\

    \midrule

    \cpp{bool operator>=(const continuation& other) const noexcept} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Every invalid \cont instance compares equal to every other
              invalid instance. But because the running context is never
              represented by a valid \cont instance, and because every
              suspended context is represented by exactly one valid
              instance, \emph{no valid instance can ever compare equal to any
              other valid instance.}
    \item[2)] These comparisons establish an arbitrary total ordering of \cont
              instances, for example to store in ordered containers. (However,
              key lookup is meaningless, since you cannot construct a search
              key that would compare equal to any entry.) There is no
              significance to the relative order of two instances.
\end{description}


\subparagraph*{swap}
swaps two \cont instances\\

\begin{tabular}{ l l }
    \midrule

    \cpp{void swap(continuation& other) noexcept} & (1)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] Exchanges the state of \cpp{*this} with \cpp{other}.\\
\end{description}


\uabschnitt{std::callcc()}

create and enter a new context, capturing the current execution context (the
{\bfseries current continuation}) in a \cont and passing it to the
specified \entryfn.\\
\callcc acts as a factory-function: it creates and starts a new execution context
(stack etc.) and returns a continuation that represents the rest of the execution
context's computation.\footnote{A continuation is an abstract concept that
represents the context state at a given point during the execution of a program
(for more details see P0534R0, section \emph{Continuation}\cite{P0534R0})}\\
\callcc explicitly expresses the creation of a new execution
context and the switch to the other execution path.\\

\begin{tabular}{ l l }
    \midrule

    \cpp{template< typename Fn, typename ...Args >}\\
    \cpp{continuation callcc( Fn && fn, Args ...args)} & (1)\\

    \midrule

    \cpp{template< typename StackAlloc, typename Fn, typename ...Args >}\\
    \cpp{continuation callcc( std::allocator\_arg\_t, StackAlloc salloc, Fn && fn, Args ...args)} & (2)\\

    \midrule
\end{tabular}

\begin{description}
    \item[1)] creates and immediately enters the new execution context
              (executing \cpp{fn}). The current execution context is suspended,
              wrapped in a continuation (\cont) and passed as argument to
              \cpp{fn}.
    \item[2)] takes a callable as argument, requirements as for (1). The stack
              is constructed using \emph{salloc}.
              \footnote{This constructor is an optional part of the
              proposal. It might be that implementations can reliably infer the
              optimal stack representation.}
\end{description}

{\bfseries Parameters}
\begin{description}
    \item[fn]      callable (function, lambda, functor) executed in the new
                   context; expected signature \cpp{continuation(continuation &&)} 
    \item[...args] data transferred to the new context\\
\end{description}

{\bfseries Return value}
\begin{description}
    \item[continuation] the returned instance represents the execution context
                        (continuation) that was suspended in order to
                        resume the current context
\end{description}

{\bfseries Exceptions}
\begin{description}
    \item[1)] calls \cpp{std::terminate} if an exception escapes \entryfn\ 
              \cpp{fn}\\
\end{description}

{\bfseries Notes}
\newline
\callcc preserves the execution context of the calling context as well as stack
parts like \emph{parameter list} and \emph{return address}.
\footnote{required only by some x86 ABIs} Those data are restored if the calling
context is resumed.\\
A suspended \cpp{continuation} can be destroyed. Its resources will be cleaned
up at that time.\\
On return \cpp{fn} has to specify a \cont to which the execution control is
transferred.\\
If an instance with valid state goes out of scope and its \cpp{fn} has not yet
returned, the stack is unwound and deallocated.
