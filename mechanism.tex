\newpage
\abschnitt{The switch mechanism}\label{mechanism}

Modern \bfs{micro-processors} are \bfs{register machines}; the content of
processor registers represent the execution context of the program at a given
point in time.\\
\bfs{Operating systems} simulate parallel execution of programs on a single
processor by switching between programs (\bfs{context switch}) by
\bfs{preserving} and \bfs{restoring} the content of \bfs{all registers}.\\

For \cc, not all registers need be preserved because the context switch is
effected by a visible function call. It need not be undetectable like an
operating-system context switch; it only needs to be as transparent as a call
to any other function. The calling convention -- the
part of the ABI that specifies how a function's arguments and return values are
passed -- determines which subset of micro-processor registers must be
preserved by the called function.\\

A \cont preserves the execution context: the state of
the register machine, including the stack as well as the instruction pointer.\\

The \bfs{calling convention}\cite{SYSVABI} of \bfs{SYSV ABI} for \bfs{x86\_64}
architecture determines that general purpose registers R12, R13, R14, R15, RBX
and RBP must be preserved by the function - the first arguments are passed
to functions via RDI, RSI, RDX, RCX, R8 and R9 and return values are stored in
RAX, RDX.\\

\asmfn{jump_x86_64.S}

The code fragment above, taken from Boost.Context\cite{bcontext}, shows how the
context switch might be implemented for \bfs{SYSV ABI}/\bfs{x86\_64}.\\
Line (1) reserves space on the stack of the current context to hold the content of
registers R12-R15, RBX and RBP. The address of the stack pointer is preserved in
register RAX at line (10) for later use.\\
The \bfs{return address}, i.e. the address of the instruction that will be
executed after this function returns, is left on the stack. Other architectures
store the return address in a special register (link register) instead of the
stack; in that case the link register must be preserved too.\\
At line (12) the stack pointer gets assigned to the address of the
continuation to be resumed -- in fact, the continuation stores a
stack address; that stack pointer value was passed in RDI as the first argument.\\
The return address is loaded into register R8 at line (14); with the indirect
jump at line (28) the \bfs{continuation} is \bfs{resumed}.\\
As required by the calling convention, registers R12-R15, RBX and RBP are
restored at lines (16) - (21).\\
The stack address, preserved in RAX at line (10), of the
\bfs{suspended continuation} is \bfs{returned} as a \bfs{one-shot continuation}.\\

In fact, \cc is an extended function call. The \bfs{general purpose
registers} specified by the calling convention are preserved. In addition, the
\bfs{stack pointer} and \bfs{instruction pointer} are preserved and exchanged
too -- thus, from the point of view of calling code, \cc behaves like an
ordinary function call.\\
In other words, \cc acts like a simple function invocation, with the
same performance characteristics (in terms of CPU cycles).
